# -*- coding: utf-8 -*-
"""DeFi Wallet Credit Scoring.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fqAunbhpCBRgqzvRJNyVgnFmNXrvc2Uu
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from google.colab import files
import json

uploaded = "/content/user-wallet-transactions.json"

# Load JSON file
def load_data(filename):
    with open(filename) as f:
        data = json.load(f)
        return pd.json_normalize(data)

# Convert amount and price fields to float
def parse_float(val):
    try:
        return float(val)
    except:
        return 0.0

df['amount'] = df['actionData.amount'].apply(parse_float)
df['price_usd'] = df['actionData.assetPriceUSD'].apply(parse_float)
df['timestamp'] = pd.to_datetime(df['timestamp'])
df['usd_value'] = df['amount'] * df['price_usd']

# Inspect data structure
print(df.info())
print("\nAction Counts:")
print(df['action'].value_counts())

def engineer_features(df):
    # Ensure timestamp is in datetime format, assuming it's currently in seconds if not already
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s', errors='coerce')
    df['actionData.principalAmount'] = pd.to_numeric(df['actionData.principalAmount'], errors='coerce')

    grp = df.groupby('userWallet')

    feats = pd.DataFrame({
        'tx_count': grp.size(),
        'n_deposit': grp['action'].apply(lambda x: (x=='deposit').sum()),
        'n_borrow': grp['action'].apply(lambda x: (x=='borrow').sum()),
        'n_repay': grp['action'].apply(lambda x: (x=='repay').sum()),
        'n_redeem': grp['action'].apply(lambda x: (x=='redeemunderlying').sum()),
        'n_liq': grp['action'].apply(lambda x: (x=='liquidationcall').sum()),
        'amt_avg': grp['actionData.principalAmount'].mean(),
        'amt_max': grp['actionData.principalAmount'].max(),
        'active_days': grp['timestamp'].apply(lambda x: (x.max()-x.min()).days + 1),
    })

    # Handle potential division by zero
    feats['tx_per_day'] = feats['tx_count'] / feats['active_days'].replace(0,1)
    feats['repay_rate'] = feats['n_repay'] / feats['n_borrow'].replace(0, np.nan)
    feats['repay_rate'] = feats['repay_rate'].fillna(0) # Fill NaN with 0 for wallets with no borrows

    return feats

def compute_score(features):
    # You can adjust the weights or add more features as needed
    score = (features['tx_count'] * 0.5) + (features['active_days'] * 0.3) + (features['n_deposit'] * 0.1) + (features['n_borrow'] * 0.05) + (features['n_repay'] * 0.05)
    # Check if the score column has only non-finite values
    if np.isfinite(score).all() and score.max() - score.min() > 0:
        min_score = score.min()
        max_score = score.max()
        scaled_score = 1000 * (score - min_score) / (max_score - min_score)
    else:
         scaled_score = 0 # Or handle this case as appropriate

    return scaled_score.astype(int)

features['score_raw'] = (
    features['num_deposit'] * 2 +
    features['num_repay'] * 3 +
    features['active_days'] * 1 +
    features['total_usd'] * 0.0001 -
    features['num_liquidation'] * 5 -
    features['num_borrow'] * 1
)

min_score = features['score_raw'].min()
max_score = features['score_raw'].max()
features['score'] = ((features['score_raw'] - min_score) / (max_score - min_score)) * 1000
features['score'] = features['score'].clip(0, 1000).round().astype(int)  # ensure bounded and integer

def credit_tier(score):
    if score <= 400:
        return 'Low'
    elif score <= 700:
        return 'Medium'
    else:
        return 'High'

features['credit_level'] = features['score'].apply(credit_tier)
features[['userWallet', 'score', 'credit_level']].head()

features[['userWallet', 'score','credit_level']].to_csv('wallet_scores.csv', index=False)
files.download('wallet_scores.csv')

# Plot distribution of scores
sns.histplot(features['score'], bins=10, kde=True)
plt.title('Credit Score Distribution')
plt.xlabel('Score')
plt.ylabel('Wallet Count')
plt.show()

# Analyze low vs high score wallets
low_score_wallets = features[features['score'] < 200]
high_score_wallets = features[features['score'] > 800]

print("\nLow Score Wallet Behavior:\n", low_score_wallets.describe())
print("\nHigh Score Wallet Behavior:\n", high_score_wallets.describe())

